/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package late.samples.state;

import com.google.gson.Gson;
import java.util.Iterator;
import java.util.Objects;
import java.util.stream.StreamSupport;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.coders.AvroCoder;
import org.apache.beam.sdk.coders.DefaultCoder;
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;
import org.apache.beam.sdk.options.Description;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.state.*;
import org.apache.beam.sdk.transforms.*;
import org.apache.beam.sdk.transforms.windowing.*;
import org.apache.beam.sdk.transforms.windowing.Window;
import org.apache.beam.sdk.values.*;
import org.joda.time.Duration;
import org.joda.time.Instant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LateSamplesState {

  private static final Logger logger = LoggerFactory.getLogger(LateSamplesState.class);

  public interface Options extends PipelineOptions {

    @Description("pubsub topic")
    String getTopic();

    void setTopic(String topic);
  }

  @DefaultCoder(AvroCoder.class)
  public static class Event {
    String key;
    String value;
    Long timestamp;

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      Event event = (Event) o;
      return key.equals(event.key)
          && value.equals(event.value)
          && timestamp.equals(event.timestamp);
    }

    @Override
    public int hashCode() {
      return Objects.hash(key, value, timestamp);
    }

    @Override
    public String toString() {
      return "{"
          + "key='"
          + key
          + '\''
          + ", value='"
          + value
          + '\''
          + ", timestamp="
          + new Instant(timestamp)
          + '}';
    }
  }

  public static void main(String[] args) {
    PipelineOptionsFactory.register(Options.class);
    Options options = PipelineOptionsFactory.fromArgs(args).as(Options.class);

    Pipeline pipeline = Pipeline.create(options);

    PCollection<Event> events = pipeline.apply("ingest", new IngestFromPubsub(options.getTopic()));

    events.apply(new WindowGroupState());

    pipeline.run();
  }

  private static class IngestFromPubsub extends PTransform<PBegin, PCollection<Event>> {
    private final String topic;

    IngestFromPubsub(String topic) {
      this.topic = topic;
    }

    @Override
    public PCollection<Event> expand(PBegin input) {

      return input
          .apply(PubsubIO.readMessages().fromTopic(topic))
          .apply(MapElements.into(TypeDescriptors.strings()).via(m -> new String(m.getPayload())))
          .apply(
              ParDo.of(
                  new DoFn<String, String>() {
                    @ProcessElement
                    public void process(ProcessContext c) {
                      logger.info(c.element());
                      c.output(c.element());
                    }
                  }))
          .apply(
              MapElements.into(TypeDescriptor.of(Event.class))
                  .via(m -> new Gson().fromJson(m, Event.class)));
    }
  }

  public static class WindowGroupState extends PTransform<PCollection<Event>, PCollectionTuple> {

    public static final TupleTag<KV<String, Iterable<Event>>> stateOutput = new TupleTag<>();
    public static final TupleTag<KV<String, Iterable<Event>>> groupOutput = new TupleTag<>();

    @Override
    public PCollectionTuple expand(PCollection<Event> input) {
      Window<Event> window =
          Window.<Event>into(FixedWindows.of(Duration.standardMinutes(1)))
              .triggering(
                  Repeatedly.forever(
                      AfterFirst.of(
                          AfterPane.elementCountAtLeast(1),
                          AfterProcessingTime.pastFirstElementInPane()
                              .plusDelayOf(Duration.standardMinutes(10)))))
              .withAllowedLateness(Duration.standardDays(7))
              .accumulatingFiredPanes();

      PCollection<KV<String, Event>> windowed =
          input
              .apply(
                  WithTimestamps.of((Event e) -> new Instant(e.timestamp))
                      .withAllowedTimestampSkew(new Duration(Long.MAX_VALUE)))
              .apply(window)
              .apply(WithKeys.of((Event e) -> e.key).withKeyType(TypeDescriptors.strings()));

      PCollection<KV<String, Iterable<Event>>> grouped = windowed.apply(GroupByKey.create());
      grouped.apply(
          ParDo.of(
              new DoFn<KV<String, Iterable<Event>>, String>() {
                @ProcessElement
                public void process(ProcessContext c, BoundedWindow window) {
                  logger.info(formatEvents("GROUP", window, c.element().getValue()));
                }
              }));

      PCollection<KV<String, Iterable<Event>>> stateful =
          windowed.apply(ParDo.of(new StatefulGrouping()));

      return PCollectionTuple.of(groupOutput, grouped).and(stateOutput, stateful);
    }

    private String formatEvents(
        String context, BoundedWindow window, Iterable<Event> currentEvents) {

      StringBuilder sb =
          new StringBuilder()
              .append("context=")
              .append(context)
              .append(" max_ts=")
              .append(window.maxTimestamp());

      Iterator<Event> it = currentEvents.iterator();
      if (!it.hasNext()) {
        sb.append(" EMPTY");
        return sb.toString();
      }

      String key = it.next().key;

      sb.append(" key=")
          .append(key)
          .append(" count=")
          .append(StreamSupport.stream(currentEvents.spliterator(), false).count());

      return sb.toString();
    }

    private class StatefulGrouping extends DoFn<KV<String, Event>, KV<String, Iterable<Event>>> {
      @StateId("elements_bag")
      private final StateSpec<BagState<Event>> EventBagSpec = StateSpecs.bag();

      @TimerId("timer")
      private final TimerSpec sessionExpiredSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);

      @ProcessElement
      public void process(
          ProcessContext c,
          @StateId("elements_bag") BagState<Event> events,
          @TimerId("timer") Timer timer,
          BoundedWindow window) {

        events.add(c.element().getValue());
        Iterable<Event> currentEvents = events.read();
        logger.info(formatEvents("STATE", window, currentEvents));

        c.output(KV.of(c.element().getKey(), events.read()));

        timer.offset(Duration.standardMinutes(1)).setRelative();
      }

      @OnTimer("timer")
      public void onTimer(
          OnTimerContext c, @StateId("elements_bag") BagState<Event> events, BoundedWindow window) {
        Iterable<Event> currentEvents = events.read();
        logger.info(formatEvents("STATE TIMER", window, currentEvents));
      }
    }
  }
}
