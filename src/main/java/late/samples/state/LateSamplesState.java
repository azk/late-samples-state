/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package late.samples.state;

import com.google.gson.Gson;
import java.util.Arrays;
import java.util.Objects;
import java.util.stream.StreamSupport;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.coders.AvroCoder;
import org.apache.beam.sdk.coders.DefaultCoder;
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;
import org.apache.beam.sdk.options.Description;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.state.*;
import org.apache.beam.sdk.transforms.*;
import org.apache.beam.sdk.transforms.windowing.*;
import org.apache.beam.sdk.transforms.windowing.Window;
import org.apache.beam.sdk.values.*;
import org.joda.time.Duration;
import org.joda.time.Instant;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LateSamplesState {

  private static final Logger logger = LoggerFactory.getLogger(LateSamplesState.class);

  public interface Options extends PipelineOptions {

    @Description("pubsub topic")
    String getTopic();

    void setTopic(String topic);
  }

  @DefaultCoder(AvroCoder.class)
  public static class Event {
    String key;
    String value;
    Instant timestamp;

    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      Event event = (Event) o;
      return key.equals(event.key)
          && value.equals(event.value)
          && timestamp.equals(event.timestamp);
    }

    @Override
    public int hashCode() {
      return Objects.hash(key, value, timestamp);
    }

    @Override
    public String toString() {
      return "{"
          + "key='"
          + key
          + '\''
          + ", value='"
          + value
          + '\''
          + ", timestamp="
          + timestamp
          + '}';
    }
  }

  public static void main(String[] args) {
    PipelineOptionsFactory.register(Options.class);
    Options options = PipelineOptionsFactory.fromArgs(args).as(Options.class);

    Pipeline pipeline = Pipeline.create(options);

    PCollection<Event> events = pipeline.apply("ingest", new IngestFromPubsub(options.getTopic()));

    events.apply(new WindowGroupState());

    pipeline.run();
  }

  private static class IngestFromPubsub extends PTransform<PBegin, PCollection<Event>> {
    private final String topic;

    IngestFromPubsub(String topic) {
      this.topic = topic;
    }

    @Override
    public PCollection<Event> expand(PBegin input) {

      return input
          .apply(PubsubIO.readMessages().fromTopic(topic))
          .apply(
              MapElements.into(TypeDescriptor.of(Event.class))
                  .via(m -> new Gson().fromJson(new String(m.getPayload()), Event.class)));
    }
  }

  public static class WindowGroupState extends PTransform<PCollection<Event>, PCollectionTuple> {

    public static final TupleTag<KV<String, Iterable<Event>>> stateOutput = new TupleTag<>();
    public static final TupleTag<KV<String, Iterable<Event>>> groupOutput = new TupleTag<>();

    @Override
    public PCollectionTuple expand(PCollection<Event> input) {
      Window<Event> window =
          Window.<Event>into(FixedWindows.of(Duration.standardMinutes(1)))
              .triggering(
                  Repeatedly.forever(
                      AfterFirst.of(
                          AfterPane.elementCountAtLeast(1),
                          AfterProcessingTime.pastFirstElementInPane()
                              .plusDelayOf(Duration.standardMinutes(10)))))
              .withAllowedLateness(Duration.standardDays(7))
              .accumulatingFiredPanes();

      PCollection<KV<String, Event>> windowed =
          input
              .apply(
                  WithTimestamps.of((Event e) -> e.timestamp)
                      .withAllowedTimestampSkew(new Duration(Long.MAX_VALUE)))
              .apply(window)
              .apply(WithKeys.of((Event e) -> e.key).withKeyType(TypeDescriptors.strings()));

      PCollection<KV<String, Iterable<Event>>> grouped = windowed.apply(GroupByKey.create());
      PCollection<KV<String, Iterable<Event>>> stateful =
          windowed.apply(ParDo.of(new StatefulGrouping()));

      return PCollectionTuple.of(groupOutput, grouped).and(stateOutput, stateful);
    }

    private class StatefulGrouping extends DoFn<KV<String, Event>, KV<String, Iterable<Event>>> {
      @StateId("elements_bag")
      private final StateSpec<BagState<Event>> EventBagSpec = StateSpecs.bag();

      @TimerId("timer")
      private final TimerSpec sessionExpiredSpec = TimerSpecs.timer(TimeDomain.PROCESSING_TIME);

      @ProcessElement
      public void process(
          ProcessContext c,
          @StateId("elements_bag") BagState<Event> events,
          @TimerId("timer") Timer timer,
          BoundedWindow window) {

        Event event = c.element().getValue();
        Iterable<Event> currentEvents = events.read();
        logger.info(
            String.format(
                "%s event=%s state=%s", window.toString(), event, formatEvents(currentEvents)));

        events.add(event);
        c.output(KV.of(c.element().getKey(), events.read()));

        timer.offset(Duration.standardMinutes(1)).setRelative();
      }

      private String formatEvents(Iterable<Event> currentEvents) {
        StringBuilder sb = new StringBuilder();

        StreamSupport.stream(currentEvents.spliterator(), false)
            .forEach(event -> sb.append(event.toString()));

        String res = sb.toString();

        if (res.equals("")) {
          res = "EMPTY";
        }

        return res;
      }

      @OnTimer("timer")
      public void onTimer(
          OnTimerContext c, @StateId("elements_bag") BagState<Event> events, BoundedWindow window) {
        Iterable<Event> currentEvents = events.read();
        logger.info(
            String.format(
                "%s event=%s state=%s", window.toString(), "timer", formatEvents(currentEvents)));
      }
    }
  }
}
