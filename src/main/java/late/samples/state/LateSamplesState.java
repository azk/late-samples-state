/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package late.samples.state;

import com.google.gson.Gson;
import java.util.Arrays;
import java.util.Objects;

import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.coders.AvroCoder;
import org.apache.beam.sdk.coders.DefaultCoder;
import org.apache.beam.sdk.io.gcp.pubsub.PubsubIO;
import org.apache.beam.sdk.options.Description;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.state.BagState;
import org.apache.beam.sdk.state.StateSpec;
import org.apache.beam.sdk.state.StateSpecs;
import org.apache.beam.sdk.transforms.*;
import org.apache.beam.sdk.transforms.windowing.*;
import org.apache.beam.sdk.transforms.windowing.Window;
import org.apache.beam.sdk.values.*;
import org.joda.time.Duration;
import org.joda.time.Instant;

public class LateSamplesState {

  public interface Options extends PipelineOptions {

    @Description("pubsub topic")
    String getTopic();

    void setTopic(String topic);
  }

  @DefaultCoder(AvroCoder.class)
  public static class Event {
    String key;
    String value;
    Instant timestamp;


    @Override
    public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      Event event = (Event) o;
      return key.equals(event.key) &&
              value.equals(event.value) &&
              timestamp.equals(event.timestamp);
    }

    @Override
    public int hashCode() {
      return Objects.hash(key, value, timestamp);
    }
  }

  public static void main(String[] args) {
    Options options = PipelineOptionsFactory.fromArgs(args).as(Options.class);

    Pipeline pipeline = Pipeline.create(options);

    PCollection<Event> events =
        pipeline.apply("ingest", new IngestFromPubsub(options.getTopic()));

    events.apply(new WindowGroupState());

    pipeline.run();
  }

  private static class IngestFromPubsub extends PTransform<PBegin, PCollection<Event>> {
    private final String topic;

    IngestFromPubsub(String topic) {
      this.topic = topic;
    }

    @Override
    public PCollection<Event> expand(PBegin input) {

      return input
          .apply(PubsubIO.readMessages().fromTopic(topic))
          .apply(
              MapElements.into(TypeDescriptor.of(Event.class))
                  .via(m -> new Gson().fromJson(Arrays.toString(m.getPayload()), Event.class)));
    }
  }

  public static class WindowGroupState extends PTransform<PCollection<Event>, PCollectionTuple> {

    public static final TupleTag<KV<String, Iterable<Event>>> stateOutput = new TupleTag<>();
    public static final TupleTag<KV<String, Iterable<Event>>> groupOutput = new TupleTag<>();

    @Override
    public PCollectionTuple expand(PCollection<Event> input) {
      Window<Event> window =
          Window.<Event>into(FixedWindows.of(Duration.standardMinutes(1)))
              .triggering(
                  Repeatedly.forever(
                      AfterFirst.of(
                          AfterPane.elementCountAtLeast(1),
                          AfterProcessingTime.pastFirstElementInPane()
                              .plusDelayOf(Duration.standardMinutes(10)))))
              .withAllowedLateness(Duration.standardDays(7))
              .accumulatingFiredPanes();

      PCollection<KV<String, Event>> windowed = input
              .apply(WithTimestamps.of((Event e) -> e.timestamp)
                      .withAllowedTimestampSkew(new Duration(Long.MAX_VALUE)))
              .apply(window)
              .apply(WithKeys.of((Event e)->e.key).withKeyType(TypeDescriptors.strings()));

      PCollection<KV<String, Iterable<Event>>> grouped = windowed.apply(GroupByKey.create());
      PCollection<KV<String, Iterable<Event>>> stateful = windowed.apply(ParDo.of(new StatefulGrouping()));

      return PCollectionTuple.of(groupOutput, grouped).and(stateOutput, stateful);
    }

    private class StatefulGrouping extends DoFn<KV<String, Event>, KV<String, Iterable<Event>>> {
      @StateId("elements_bag")
      private final StateSpec<BagState<Event>> EventBagSpec =
              StateSpecs.bag();

      @ProcessElement
      public void process(ProcessContext c, @StateId("elements_bag") BagState<Event> samples) {
        samples.add(c.element().getValue());
        c.output(KV.of(c.element().getKey(), samples.read()));
      }
    }
  }
}
